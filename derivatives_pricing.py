# -*- coding: utf-8 -*-
"""derivatives_pricing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hq4yaup6ig4lkdAHouigx3vD-sZGrXq9
"""

# Import Libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# 1. Data Collection
# Example: Download S&P 500 (SPY) data
symbol = "SPY"
data = yf.download(symbol, start="2015-01-01", end="2023-12-31")

# Example: Additional implied volatility data (Use VIX as proxy)
vix = yf.download("^VIX", start="2015-01-01", end="2023-12-31")

# Merge DataFrames
data["VIX"] = vix["Close"]
data.dropna(inplace=True)

# 2. Feature Engineering
# Moving Averages, Returns, and Volatility
data["Return"] = data["Close"].pct_change()
data["MA10"] = data["Close"].rolling(10).mean()
data["Volatility_10"] = data["Return"].rolling(10).std()

# Drop NaNs
data.dropna(inplace=True)

# Select features for model
features = ["Close", "VIX", "MA10", "Volatility_10"]
df = data[features]

# Scaling
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(df)

# 3. Prepare Time Series Data for LSTM
def create_sequences(data, seq_length):
    X, y = [], []
    for i in range(len(data) - seq_length):
        X.append(data[i:i+seq_length])
        y.append(data[i+seq_length, 0])  # Predict 'Close' price
    return np.array(X), np.array(y)

SEQ_LENGTH = 30
X, y = create_sequences(scaled_data, SEQ_LENGTH)

# Train/Test split
split = int(0.8 * len(X))
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

# 4. Build LSTM Model for Price Prediction
model = Sequential([
    LSTM(64, return_sequences=True, input_shape=(SEQ_LENGTH, len(features))),
    Dropout(0.2),
    LSTM(64),
    Dropout(0.2),
    Dense(1)
])

model.compile(optimizer='adam', loss='mse')
model.summary()

# Train
history = model.fit(X_train, y_train, epochs=20, batch_size=32, validation_split=0.1)

# 5. Predictions
preds = model.predict(X_test)
preds_rescaled = scaler.inverse_transform(
    np.hstack([preds, np.zeros((len(preds), len(features)-1))])
)[:,0]

y_test_rescaled = scaler.inverse_transform(
    np.hstack([y_test.reshape(-1,1), np.zeros((len(y_test), len(features)-1))])
)[:,0]

rmse = np.sqrt(mean_squared_error(y_test_rescaled, preds_rescaled))
print(f"Test RMSE: {rmse:.2f}")

plt.figure(figsize=(12,6))
plt.plot(y_test_rescaled, label="Actual Price")
plt.plot(preds_rescaled, label="Predicted Price")
plt.legend()
plt.title("LSTM Model - Derivative Underlying Price Prediction")
plt.show()

# 6. Volatility Forecasting (Simple GARCH or LSTM could be added later)
# For now, use predicted prices to derive estimated future volatility
pred_returns = np.diff(preds_rescaled) / preds_rescaled[:-1]
pred_volatility = pd.Series(pred_returns).rolling(10).std()

plt.figure(figsize=(10,4))
plt.plot(pred_volatility, label="Predicted Volatility")
plt.legend()
plt.show()

# 7. Simple Trading Strategy Simulation
# Buy when predicted price > todayâ€™s price; Sell otherwise
signals = np.where(preds_rescaled[1:] > y_test_rescaled[:-1], 1, -1)
returns = signals * (y_test_rescaled[1:] - y_test_rescaled[:-1]) / y_test_rescaled[:-1]
cumulative_returns = (1 + returns).cumprod()

plt.figure(figsize=(10,4))
plt.plot(cumulative_returns, label="Strategy Equity Curve")
plt.legend()
plt.title("ML-based Derivative Trading Strategy")
plt.show()

